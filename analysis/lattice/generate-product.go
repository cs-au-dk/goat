//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"

	ttemplate "text/template"
)

type field struct {
	Accessor   string
	Typename   string
	typecast   string
	Stringname string
}

func (f field) Typecast() string {
	if f.typecast == "Element" {
		return ""
	}
	return "." + f.typecast + "()"
}

func main() {
	productName := os.Args[1]
	startfilename := strings.TrimSuffix(os.Getenv("GOFILE"), ".go")

	fields := []field{}
	for _, arg := range os.Args[2:] {
		parts := strings.Split(arg, ",")
		if len(parts) != 4 {
			log.Fatalln(arg, "does not contain the required 4 parts")
		}

		fields = append(fields, field{
			parts[0], parts[1],
			parts[2], parts[3],
		})
	}

	templateB, err := os.ReadFile("product-wrapper-template.go")
	if err != nil {
		log.Fatal(err)
	}

	template := string(templateB)

	// Discard the first two lines
	template = strings.SplitN(template, "\n", 3)[2]

	// Add typesafe accessor and update methods
	templ := ttemplate.Must(ttemplate.New("").Parse(`
{{ range $index, $field := . }}
func (w WrappedProductElement) {{ $field.Accessor }}() {{ $field.Typename }} {
	return w.product.Get({{ $index }}){{ $field.Typecast }}
}

func (w WrappedProductElement) Update{{ $field.Accessor }}(value {{ $field.Typename }}) WrappedProductElement {
	w.product = w.product.Update({{ $index }}, value)
	return w
}
{{ end }}`))

	var buf bytes.Buffer
	err = templ.Execute(&buf, fields)
	if err != nil {
		log.Fatalln(err)
	}

	// Add a safety check function
	templ = ttemplate.Must(ttemplate.New("").Parse(`
func _checkWrappedProductElement(el WrappedProductElement) {
	if len(*el.product.prod) != {{ len . }} {
		panic("Product length mismatch. Expected {{ len . }}.")
	}

	{{ range . }}el.{{ .Accessor }}()
	{{ end }}
}`))

	err = templ.Execute(&buf, fields)
	if err != nil {
		log.Fatalln(err)
	}

	template = template + buf.String()

	// Generate STRING_ENTRIES
	entries := []string{}
	for _, field := range fields {
		entries = append(entries, fmt.Sprintf("\t\t{\"%s\", w.%s()},", field.Stringname, field.Accessor))
	}

	for _, repl := range []struct{ src, dest string }{
		{`WrappedProductElement`, productName},
		{`(?m)^.*STRING_ENTRIES\,`, strings.Join(entries, "\n")},
	} {
		re := regexp.MustCompile(repl.src)
		template = re.ReplaceAllString(template, repl.dest)

	}

	template = fmt.Sprintf("// Code generated by generate-product.go for %s. DO NOT EDIT.\n\n%s", productName, template)

	finalName := startfilename + "_gen.go"
	os.WriteFile(finalName, []byte(template), 0666)

	cmd := exec.Command("goimports", "-w", finalName)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully generated", finalName)
}
